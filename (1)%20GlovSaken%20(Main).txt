-- Services declaration
local playersService = game:GetService("Players")
local lightingService = game:GetService("Lighting")
local userInputService = game:GetService("UserInputService")
local runService = game:GetService("RunService")
local replicatedStorage = game:GetService("ReplicatedStorage")
local materialService = game:GetService("MaterialService")
local workspaceService = game:GetService("Workspace")
local statsService = game:GetService("Stats")
local debrisService = game:GetService("Debris")
local textChatService = game:GetService("TextChatService")

-- Client references
local clientPlayer = playersService.LocalPlayer
local PlayerGui = clientPlayer:WaitForChild("PlayerGui", 10)

-- Load WindUI library
local WindUI = loadstring(game:HttpGet("https://github.com/Footagesus/WindUI/releases/latest/download/main.lua"))()

-- Create main window
local Window = WindUI:CreateWindow({
    Title = "GlovSaken Main 1.9.5.9",
    Icon = "sparkles",
    Author = "By GlovDev",
    Folder = "GlovSakenScript",
    Size = UDim2.fromOffset(350, 300),
    Transparent = false,
    Theme = "Dark",
    Resizable = false,
    SideBarWidth = 150,
    HideSearchBar = true,
    ScrollBarEnabled = false,
})

-- Window toggle key
Window:SetToggleKey(Enum.KeyCode.L)

-- Window text font
WindUI:SetFont("rbxasset://fonts/families/AccanthisADFStd.json")

-- Mobile open button configuration
Window:EditOpenButton({
    Title = "GlovSaken Main",
    Icon = "sparkles",
    CornerRadius = UDim.new(0,16),
    StrokeThickness = 0,
    Color = ColorSequence.new(
        Color3.fromHex("000000"), 
        Color3.fromHex("000000")
    ),
    OnlyMobile = true,
    Enabled = true,
    Draggable = true,
})

----------------------------------------------------------------
-- Setting Tab
----------------------------------------------------------------
local SettingTab = Window:Tab({
    Title = "Setting",
    Icon = "settings",
})

----------------------------------------------------------------
-- Interface Section
----------------------------------------------------------------
local InterfaceSection = SettingTab:Section({
    Title = "Interface",
    Opened = true,
})

-- Spoof Usernames - Variables
local settingSpoofUsernamesActive = false
local settingSpoofName = "SpoofedByGlovSaken"
local settingOriginalTexts = {}        -- Stores original username text
local settingSpoofConnections = {}     -- Stores all active connections

-- Apply spoof to a single username label
local function settingSpoofUsernameLabel(label)
    if not (label:IsA("TextLabel") or label:IsA("TextButton")) then return end
    if label.Name ~= "Username" then return end

    if not settingOriginalTexts[label] then
        settingOriginalTexts[label] = label.Text
    end

    if settingSpoofUsernamesActive then
        label.Text = settingSpoofName
    end
end

-- Restore all original usernames
local function settingRestoreAllUsernames()
    for label, original in pairs(settingOriginalTexts) do
        if label and label.Parent then
            label.Text = original
        end
    end
    settingOriginalTexts = {}
end

-- Scan both MainUI and TemporaryUI for existing username labels
local function settingScanPlayerUI()
    local playerGui = playersService.LocalPlayer:FindFirstChild("PlayerGui")
    if not playerGui then return end

    local targets = {}
    local mainUI = playerGui:FindFirstChild("MainUI")
    local tempUI = playerGui:FindFirstChild("TemporaryUI")

    if mainUI then table.insert(targets, mainUI) end
    if tempUI then table.insert(targets, tempUI) end

    task.defer(function()
        for _, ui in ipairs(targets) do
            for _, obj in ipairs(ui:GetDescendants()) do
                if (obj:IsA("TextLabel") or obj:IsA("TextButton")) and obj.Name == "Username" then
                    settingSpoofUsernameLabel(obj)
                end
            end
        end
    end)
end

-- Start username spoofing system (connections + initial scan)
local function settingStartSpoofing()
    for _, conn in ipairs(settingSpoofConnections) do
        if conn.Connected then conn:Disconnect() end
    end
    settingSpoofConnections = {}

    local playerGui = playersService.LocalPlayer:FindFirstChild("PlayerGui")
    if not playerGui then return end

    settingScanPlayerUI()

    local function watchUI(ui)
        if not ui then return end
        local conn = ui.DescendantAdded:Connect(function(obj)
            if settingSpoofUsernamesActive and (obj:IsA("TextLabel") or obj:IsA("TextButton")) and obj.Name == "Username" then
                task.defer(settingSpoofUsernameLabel, obj)
            end
        end)
        table.insert(settingSpoofConnections, conn)
    end

    watchUI(playerGui:FindFirstChild("MainUI"))
    watchUI(playerGui:FindFirstChild("TemporaryUI"))

    local uiAppearConn = playerGui.ChildAdded:Connect(function(child)
        if child.Name == "MainUI" or child.Name == "TemporaryUI" then
            if settingSpoofUsernamesActive then
                task.delay(0.1, settingScanPlayerUI)
                watchUI(child)
            end
        end
    end)
    table.insert(settingSpoofConnections, uiAppearConn)
end

-- Stop spoofing and restore original names
local function settingStopSpoofing()
    for _, conn in ipairs(settingSpoofConnections) do
        if conn.Connected then conn:Disconnect() end
    end
    settingSpoofConnections = {}
    settingRestoreAllUsernames()
end

InterfaceSection:Toggle({
    Title = "Spoof Usernames",
    Type = "Checkbox",
    Default = false,
    Callback = function(state)
        settingSpoofUsernamesActive = state
        if state then
            settingStartSpoofing()
        else
            settingStopSpoofing()
        end
    end
})

-- Keep chat always visible
local settingShowLogsChatEnabled = false
local settingShowLogsChatConnection = nil

local function settingKeepChatVisible()
    if not settingShowLogsChatEnabled then return end
    local chatWindow = textChatService:FindFirstChild("ChatWindowConfiguration")
    local chatInput = textChatService:FindFirstChild("ChatInputBarConfiguration")
    if chatWindow and not chatWindow.Enabled then chatWindow.Enabled = true end
    if chatInput and not chatInput.Enabled then chatInput.Enabled = true end
end

InterfaceSection:Toggle({
    Title = "Show Chat Logs",
    Type = "Checkbox",
    Default = false,
    Callback = function(state)
        settingShowLogsChatEnabled = state
        if settingShowLogsChatConnection then
            settingShowLogsChatConnection:Disconnect()
            settingShowLogsChatConnection = nil
        end
        if state then
            settingKeepChatVisible()
            settingShowLogsChatConnection = runService.Heartbeat:Connect(settingKeepChatVisible)
            local chatWindow = textChatService:FindFirstChild("ChatWindowConfiguration")
            local chatInput = textChatService:FindFirstChild("ChatInputBarConfiguration")
            if chatWindow then chatWindow:GetPropertyChangedSignal("Enabled"):Connect(settingKeepChatVisible) end
            if chatInput then chatInput:GetPropertyChangedSignal("Enabled"):Connect(settingKeepChatVisible) end
        end
    end
})

-- Round timer position controller
local settingTimerPosition = "Middle"

local function settingApplyTimerPosition()
    local roundTimer = playersService.LocalPlayer.PlayerGui:FindFirstChild("RoundTimer")
    local main = roundTimer and roundTimer:FindFirstChild("Main")
    if main then
        local xPos = settingTimerPosition == "Middle" and 0.5 or 0.9
        main.Position = UDim2.new(xPos, 0, main.Position.Y.Scale, main.Position.Y.Offset)
    end
end

settingApplyTimerPosition()

InterfaceSection:Dropdown({
    Title = "Set Timer Position",
    Values = {"Middle", "Right"},
    Value = "Middle",
    Callback = function(value)
        settingTimerPosition = value
        settingApplyTimerPosition()
    end
})

-- Respawn handler for interface settings
playersService.LocalPlayer.CharacterAdded:Connect(function()
    task.delay(1, function()
        if settingSpoofUsernamesActive then
            settingStartSpoofing()
        end
        settingApplyTimerPosition()
    end)
end)

----------------------------------------------------------------
-- Global Tab
----------------------------------------------------------------
local GlobalTab = Window:Tab({
    Title = "Global",
    Icon = "globe",
    Locked = false,
})

----------------------------------------------------------------
-- Stamina Section
----------------------------------------------------------------
local StaminaSection = GlobalTab:Section({
    Title = "Stamina",
    Opened = true,
})

-- Infinite Stamina - Variables
local clientInfiniteStamina = false
local clientOriginalMinStamina = nil

-- Get reference to the Sprinting module
local function clientGetStaminaModule()
    local success, module = pcall(function()
        return require(replicatedStorage.Systems.Character.Game.Sprinting)
    end)
    return success and module or nil
end

-- Save the original MinStamina value
local function clientSaveOriginal()
    local stamina = clientGetStaminaModule()
    if not stamina then return end
    clientOriginalMinStamina = stamina.MinStamina or 0
end

-- Apply infinite stamina by setting MinStamina to -1000
local function clientApplyInfinite()
    local stamina = clientGetStaminaModule()
    if not stamina then return end
    stamina.MinStamina = -1000
end

-- Restore original MinStamina value
local function clientRestoreOriginal()
    if clientOriginalMinStamina == nil then return end
    local stamina = clientGetStaminaModule()
    if not stamina then return end
    stamina.MinStamina = clientOriginalMinStamina
end

StaminaSection:Toggle({
    Title = "Infinite Stamina",
    Type = "Checkbox",
    Default = false,
    Callback = function(state)
        clientInfiniteStamina = state
        if state then
            clientSaveOriginal()
            clientApplyInfinite()
        else
            clientRestoreOriginal()
        end
    end
})

-- Reapply infinite stamina after character respawn
playersService.LocalPlayer.CharacterAdded:Connect(function()
    task.delay(1, function()
        if clientInfiniteStamina then
            clientSaveOriginal()
            clientApplyInfinite()
        end
    end)
end)

-- Initial character check on script load
if playersService.LocalPlayer.Character then
    task.delay(1, function()
        if clientInfiniteStamina then
            clientSaveOriginal()
            clientApplyInfinite()
        end
    end)
end

----------------------------------------------------------------
-- Status Section
----------------------------------------------------------------
local StatusSection = GlobalTab:Section({
    Title = "Status",
    Opened = true,
})

-- Status groups to block (only selected ones)
local avoidStatusGroups = {
    Slowness = {
        active = false,
        paths = { "Modules.StatusEffects.Slowness" }
    },
    Hallucination = {
        active = false,
        paths = { "Modules.StatusEffects.KillerExclusive.Hallucination" }
    },
    Visual = {
        active = false,
        paths = {
            "Modules.StatusEffects.Blindness",
            "Modules.StatusEffects.KillerExclusive.Glitched",
            "Modules.StatusEffects.SurvivorExclusive.Subspaced"
        }
    }
}

-- Cache for original module scripts
local avoidOriginalModules = {}

-- Get a descendant using dot-separated path
local function avoidGetDescendantFromPath(parent, path)
    local current = parent
    for segment in string.gmatch(path, "[^%.]+") do
        current = current:FindFirstChild(segment)
        if not current then return nil end
    end
    return current
end

-- Save original module and its source code
local function avoidSaveOriginal(path)
    if avoidOriginalModules[path] then return end
    local module = avoidGetDescendantFromPath(replicatedStorage, path)
    if module and module:IsA("ModuleScript") then
        local clone = module:Clone()
        avoidOriginalModules[path] = {
            clone = clone,
            source = module.Source
        }
    end
end

-- Restore destroyed module with original source
local function avoidRestoreModule(path)
    local data = avoidOriginalModules[path]
    if not data then return end
    local current = avoidGetDescendantFromPath(replicatedStorage, path)
    if current then current:Destroy() end
    local parentPath = path:match("^(.-%.?[^%.]+)$")
    local parent = avoidGetDescendantFromPath(replicatedStorage, parentPath)
    if parent then
        local restored = data.clone
        restored.Source = data.source
        restored.Parent = parent
    end
end

-- Destroy module to block status effect
local function avoidDestroyModule(path)
    avoidSaveOriginal(path)
    local module = avoidGetDescendantFromPath(replicatedStorage, path)
    if module then module:Destroy() end
end

-- Toggle a status group on/off
local function avoidToggleGroup(groupName)
    local group = avoidStatusGroups[groupName]
    if not group then return end
    group.active = not group.active
    for _, path in ipairs(group.paths) do
        if group.active then
            avoidDestroyModule(path)
        else
            avoidRestoreModule(path)
        end
    end
    -- Start background loop if any group is active
    local anyActive = false
    for _, g in pairs(avoidStatusGroups) do
        if g.active then anyActive = true; break end
    end
    if anyActive then
        avoidStartStatusLoop()
    else
        if avoidStatusLoop then
            task.cancel(avoidStatusLoop)
            avoidStatusLoop = nil
        end
    end
end

-- Background loop: re-destroy modules every 0.8 seconds
local avoidStatusLoop = nil
local function avoidStartStatusLoop()
    if avoidStatusLoop then return end
    avoidStatusLoop = task.spawn(function()
        while true do
            local anyActive = false
            for _, group in pairs(avoidStatusGroups) do
                if group.active then
                    anyActive = true
                    for _, path in ipairs(group.paths) do
                        local module = avoidGetDescendantFromPath(replicatedStorage, path)
                        if module then module:Destroy() end
                    end
                end
            end
            if not anyActive then break end
            task.wait(0.8)
        end
        avoidStatusLoop = nil
    end)
end

-- Create toggle buttons for each status group
StatusSection:Button({
    Title = "Avoid Slowness",
    Callback = function() avoidToggleGroup("Slowness") end
})

StatusSection:Button({
    Title = "Avoid Hallucination",
    Callback = function() avoidToggleGroup("Hallucination") end
})

StatusSection:Button({
    Title = "Avoid Visual Effects",
    Callback = function() avoidToggleGroup("Visual") end
})

-- Reset all status blocks on respawn
playersService.LocalPlayer.CharacterAdded:Connect(function()
    avoidOriginalModules = {}
    for _, group in pairs(avoidStatusGroups) do
        group.active = false
    end
    if avoidStatusLoop then
        task.cancel(avoidStatusLoop)
        avoidStatusLoop = nil
    end
end)

----------------------------------------------------------------
-- Network Section
----------------------------------------------------------------
local NetworkSection = GlobalTab:Section({
    Title = "Network",
    Opened = true,
})

-- Ghosting & Lag Mode - Variables
local inviGhostingActive = false
local inviLagModeActive = false
local inviBlockNetworkUpdates = false
local inviLagLoopRunning = false

-- Activate full ghosting (block all position updates)
local function inviActivateGhosting()
    inviBlockNetworkUpdates = true
end

-- Deactivate ghosting (allow updates again)
local function inviDeactivateGhosting()
    inviBlockNetworkUpdates = inviLagModeActive
end

-- Start alternating lag mode (2s ghost, 2s sync)
local function inviActivateLagMode()
    if inviLagLoopRunning then return end
    inviLagLoopRunning = true
    task.spawn(function()
        while inviLagModeActive do
            inviBlockNetworkUpdates = true
            task.wait(2)
            if not inviLagModeActive then break end
            inviBlockNetworkUpdates = false
            task.wait(2)
        end
        inviLagLoopRunning = false
    end)
end

-- Stop lag mode
local function inviDeactivateLagMode()
    inviLagLoopRunning = false
    inviBlockNetworkUpdates = inviGhostingActive
end

-- Reset network states on respawn
playersService.LocalPlayer.CharacterAdded:Connect(function()
    inviGhostingActive = false
    inviLagModeActive = false
    inviBlockNetworkUpdates = false
    inviLagLoopRunning = false
end)

-- Hook UnreliableRemoteEvent to block "UpdCF" packets
local function inviSetupNetworkHook()
    local modules = replicatedStorage:FindFirstChild("Modules")
    if not modules then return end
    local network = modules:FindFirstChild("Network")
    if not network then return end
    local unreliableRemote = network:FindFirstChild("UnreliableRemoteEvent")
    if not unreliableRemote then return end

    local oldFireServer
    oldFireServer = hookmetamethod(game, "__namecall", function(self, ...)
        local method = getnamecallmethod()
        if method == "FireServer" and self == unreliableRemote then
            local args = {...}
            if #args > 0 and args[1] == "UpdCF" and inviBlockNetworkUpdates then
                return -- Block position update packet
            end
        end
        return oldFireServer(self, ...)
    end)
end

-- Initialize network hook at startup
task.spawn(inviSetupNetworkHook)

NetworkSection:Toggle({
    Title = "Ghosting Mode",
    Type = "Checkbox",
    Default = false,
    Callback = function(state)
        inviGhostingActive = state
        if state then
            inviActivateGhosting()
        else
            inviDeactivateGhosting()
        end
    end
})

NetworkSection:Toggle({
    Title = "Lag Mode",
    Type = "Checkbox",
    Default = false,
    Callback = function(state)
        inviLagModeActive = state
        if state then
            inviActivateLagMode()
        else
            inviDeactivateLagMode()
        end
    end
})

----------------------------------------------------------------
-- Hitbox Section
----------------------------------------------------------------
local HitboxSection = GlobalTab:Section({
    Title = "Hitbox",
    Opened = true,
})

-- Hitbox Expander - Variables
local hitboxActive = false
local hitboxStrength = 50
local hitboxLoop = nil
local hitboxRemote = replicatedStorage:WaitForChild("Modules"):WaitForChild("Network"):WaitForChild("RemoteEvent")

-- Valid ability names that trigger hitbox expansion
local hitboxValidAbilities = {
    ["Slash"] = true,
    ["Dagger"] = true,
    ["Charge"] = true,
    ["Punch"] = true,
    ["PlasmaBeam"] = true,
    ["Shoot"] = true,
    ["Behead"] = true,
    ["GashingWound"] = true,
    ["CorruptNature"] = true,
    ["WalkspeedOverride"] = true,
    ["Stab"] = true,
    ["VoidRush"] = true,
    ["Nova"] = true,
    ["MassInfection"] = true,
    ["Entanglement"] = true
}

-- Apply velocity boost forward during ability use
local function hitboxExtend(distance)
    local char = playersService.LocalPlayer.Character
    if not char then return end
    local hrp = char:FindFirstChild("HumanoidRootPart")
    if not hrp then return end

    local originalVel = hrp.AssemblyLinearVelocity
    local lookVector = hrp.CFrame.LookVector

    hrp.AssemblyLinearVelocity = originalVel + lookVector * distance
    runService.RenderStepped:Wait()

    if char and char.Parent and hrp and hrp.Parent then
        hrp.AssemblyLinearVelocity = originalVel
    end
end

-- Start listening for UseActorAbility events
local function hitboxStart()
    if hitboxLoop then return end
    hitboxLoop = hitboxRemote.OnClientEvent:Connect(function(action, data)
        if not hitboxActive then return end
        if action ~= "UseActorAbility" then return end
        if typeof(data) ~= "table" or not data[1] then return end

        local rawName = data[1]
        local abilityName

        if typeof(rawName) == "buffer" then
            abilityName = buffer.tostring(rawName):gsub("\"", "")
        else
            abilityName = tostring(rawName):gsub("\"", "")
        end

        if hitboxValidAbilities[abilityName] then
            local start = os.clock()
            local conn
            conn = runService.Heartbeat:Connect(function()
                if os.clock() - start >= 1.5 then
                    conn:Disconnect()
                    return
                end
                hitboxExtend(hitboxStrength)
            end)
        end
    end)
end

-- Stop hitbox listener
local function hitboxStop()
    if hitboxLoop then
        hitboxLoop:Disconnect()
        hitboxLoop = nil
    end
end

HitboxSection:Toggle({
    Title = "Hitbox Expander",
    Type = "Checkbox",
    Default = false,
    Callback = function(state)
        hitboxActive = state
        if state then
            hitboxStart()
        else
            hitboxStop()
        end
    end
})

HitboxSection:Slider({
    Title = "Hitbox Strength",
    Step = 1,
    Value = { Min = 10, Max = 100, Default = 50 },
    Callback = function(value)
        hitboxStrength = value
    end
})

-- Reconnect hitbox on respawn
playersService.LocalPlayer.CharacterAdded:Connect(function()
    task.delay(1, function()
        if hitboxActive then
            hitboxStop()
            hitboxStart()
        end
    end)
end)

----------------------------------------------------------------
-- Generator Tab
----------------------------------------------------------------
local GeneratorTab = Window:Tab({
    Title = "Generator",
    Icon = "circuit-board",
    Locked = false,
})

----------------------------------------------------------------
-- Auto Section
----------------------------------------------------------------
local AutoSection = GeneratorTab:Section({
    Title = "Auto",
    Opened = true,
})

-- Flow Solver Variables
local genFlowSolverEnabled = false
local genFlowNodeDelay = 0.04
local genFlowLineDelay = 0.60

-- Refresh PuzzleUI reference
local function genRefreshPuzzleUI()
    genPuzzleUI = playersService.LocalPlayer.PlayerGui:FindFirstChild("PuzzleUI")
end

-- Direction helper for flow connections
local function genGetDirection(currRow, currCol, otherRow, otherCol)
    if otherRow < currRow then return "up" end
    if otherRow > currRow then return "down" end
    if otherCol < currCol then return "left" end
    if otherCol > currCol then return "right" end
end

-- Calculate connections for a node
local function genGetConnections(prev, curr, nextNode)
    local connections = {}
    if prev and curr then
        local dir = genGetDirection(curr.row, curr.col, prev.row, prev.col)
        if dir == "up" then dir = "down"
        elseif dir == "down" then dir = "up"
        elseif dir == "left" then dir = "right"
        elseif dir == "right" then dir = "left" end
        if dir then connections[dir] = true end
    end
    if nextNode and curr then
        local dir = genGetDirection(curr.row, curr.col, nextNode.row, nextNode.col)
        if dir then connections[dir] = true end
    end
    return connections
end

-- Check if two nodes are adjacent
local function genIsNeighbour(r1, c1, r2, c2)
    if r2 == r1 - 1 and c2 == c1 then return "up" end
    if r2 == r1 + 1 and c2 == c1 then return "down" end
    if r2 == r1 and c2 == c1 - 1 then return "left" end
    if r2 == r1 and c2 == c1 + 1 then return "right" end
    return false
end

-- Create unique key for node coordinates
local function genCoordKey(node) return node.row .. "-" .. node.col end

-- Order path starting from an endpoint
local function genOrderPath(path, endpoints)
    if not path or #path == 0 then return path end

    local startNode
    for _, ep in endpoints or {} do
        for _, n in path do
            if n.row == ep.row and n.col == ep.col then
                startNode = { row = ep.row, col = ep.col }
                break
            end
        end
        if startNode then break end
    end

    if not startNode then
        local inPath = {}
        for _, n in path do inPath[genCoordKey(n)] = n end
        for _, n in path do
            local neighbors = 0
            for _, dr, dc in { {-1,0}, {1,0}, {0,-1}, {0,1} } do
                local key = (n.row + dr) .. "-" .. (n.col + dc)
                if inPath[key] then neighbors += 1 end
            end
            if neighbors == 1 then
                startNode = { row = n.row, col = n.col }
                break
            end
        end
    end

    if not startNode then startNode = { row = path[1].row, col = path[1].col } end

    local remaining = {}
    for _, n in path do remaining[genCoordKey(n)] = { row = n.row, col = n.col } end

    local ordered = {}
    local current = startNode
    table.insert(ordered, { row = current.row, col = current.col })
    remaining[genCoordKey(current)] = nil

    while next(remaining) do
        local found = false
        for key, node in pairs(remaining) do
            if genIsNeighbour(current.row, current.col, node.row, node.col) then
                table.insert(ordered, { row = node.row, col = node.col })
                remaining[key] = nil
                current = node
                found = true
                break
            end
        end
        if not found then break end
    end
    return ordered
end

-- Draw the complete solution node by node
local function genDrawSolution(puzzle)
    if not puzzle or not puzzle.Solution then return end

    local indices = {}
    for i = 1, #puzzle.Solution do table.insert(indices, i) end
    for i = #indices, 2, -1 do
        local j = math.random(1, i)
        indices[i], indices[j] = indices[j], indices[i]
    end

    for _, colorIndex in indices do
        local path = puzzle.Solution[colorIndex]
        local endpoints = puzzle.targetPairs[colorIndex]
        local ordered = genOrderPath(path, endpoints)

        puzzle.paths[colorIndex] = {}
        for i, node in ipairs(ordered) do
            table.insert(puzzle.paths[colorIndex], { row = node.row, col = node.col })
            local prev = ordered[i-1]
            local nextNode = ordered[i+1]
            local conn = genGetConnections(prev, node, nextNode)
            puzzle.gridConnections = puzzle.gridConnections or {}
            puzzle.gridConnections[genCoordKey(node)] = conn
            puzzle:updateGui()
            task.wait(genFlowNodeDelay)
        end

        task.wait(genFlowLineDelay)
        puzzle:checkForWin()
    end
end

-- Hook FlowGame module to auto-solve when puzzle opens
local genFlowModule = replicatedStorage:FindFirstChild("Modules")
    and replicatedStorage.Modules:FindFirstChild("Misc")
    and replicatedStorage.Modules.Misc:FindFirstChild("FlowGameManager")
    and replicatedStorage.Modules.Misc.FlowGameManager:FindFirstChild("FlowGame")

if genFlowModule then
    local FlowGame = require(genFlowModule)
    local oldNew = FlowGame.new
    FlowGame.new = function(...)
        local puzzle = oldNew(...)
        if genFlowSolverEnabled then
            task.spawn(function()
                task.wait(0.3)
                genDrawSolution(puzzle)
            end)
        end
        return puzzle
    end
end

-- UI CONTROLS
AutoSection:Toggle({
    Title = "Auto Generator",
    Type = "Checkbox",
    Default = false,
    Callback = function(state)
        genFlowSolverEnabled = state
    end
})

AutoSection:Slider({
    Title = "Node Draw Speed",
    Step = 0.02,
    Value = { Min = 0.01, Max = 0.50, Default = 0.04 },
    Callback = function(value)
        genFlowNodeDelay = value
    end
})

AutoSection:Slider({
    Title = "Delay Between Lines",
    Step = 0.10,
    Value = { Min = 0.00, Max = 1.00, Default = 0.40 },
    Callback = function(value)
        genFlowLineDelay = value
    end
})

-- Monitor PuzzleUI appearance
playersService.LocalPlayer.PlayerGui.ChildAdded:Connect(function(child)
    if child.Name == "PuzzleUI" then
        genRefreshPuzzleUI()
    end
end)

playersService.LocalPlayer.PlayerGui.ChildRemoved:Connect(function()
    genPuzzleUI = nil
end)

genRefreshPuzzleUI()

----------------------------------------------------------------
-- Visual Tab
----------------------------------------------------------------
local VisualTab = Window:Tab({
    Title = "Visual",
    Icon = "eye"
})

----------------------------------------------------------------
-- Esp Section
----------------------------------------------------------------
local EspSection = VisualTab:Section({
    Title = "Esp",
    Opened = true,
})

-- ESP States
local espKillersEnabled = false
local espSurvivorsEnabled = false
local espGeneratorsEnabled = false
local espItemsEnabled = false

-- Folder references
local killersFolder = nil
local survivorsFolder = nil
local currentMapFolder = nil

-- Connections storage
local playerConnections = {}
local mapConnections = {}
local healthConnections = {}
local progressConnections = {}

-- Get current Ingame Map folder safely
local function getCurrentMapFolder()
    local map = workspaceService:FindFirstChild("Map")
    if not map then return nil end
    local ingame = map:FindFirstChild("Ingame")
    if not ingame then return nil end
    return ingame:FindFirstChild("Map")
end

-- Add ESP to any object (player or map object)
local function addESP(obj, espName, color, isPlayer)
    if not obj or obj:FindFirstChild(espName) then return end
    local root = obj:FindFirstChild("HumanoidRootPart") or obj.PrimaryPart or obj:FindFirstChildWhichIsA("BasePart")
    if not root then return end

    pcall(function()
        -- Highlight with filled color (transparency 0.2)
        local highlight = Instance.new("Highlight")
        highlight.Name = espName
        highlight.FillColor = color
        highlight.FillTransparency = 0.8
        highlight.OutlineColor = color
        highlight.OutlineTransparency = 0
        highlight.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
        highlight.Adornee = obj
        highlight.Parent = obj

        -- Billboard label
        local billboard = Instance.new("BillboardGui")
        billboard.Name = espName .. "_Label"
        billboard.Adornee = root
        billboard.Size = UDim2.new(0, 100, 0, 20)
        -- Generators text moved higher for better visibility
        billboard.StudsOffset = Vector3.new(0, isPlayer and 3.5 or 3.8, 0)
        billboard.AlwaysOnTop = true
        billboard.MaxDistance = 1000
        billboard.Parent = obj

        local label = Instance.new("TextLabel")
        label.Size = UDim2.new(1, 0, 1, 0)
        label.BackgroundTransparency = 1
        label.TextColor3 = color
        label.TextStrokeTransparency = 0.5
        label.TextStrokeColor3 = Color3.new(0, 0, 0)
        label.TextSize = 15
        label.FontFace = Font.new("rbxasset://fonts/families/AccanthisADFStd.json")
        label.Parent = billboard

        -- Player health
        if isPlayer then
            local humanoid = obj:FindFirstChildOfClass("Humanoid")
            if humanoid then
                label.Text = obj.Name .. " (100%)"
                local conn = humanoid.HealthChanged:Connect(function()
                    if label.Parent then
                        label.Text = obj.Name .. " (" .. math.floor((humanoid.Health / humanoid.MaxHealth) * 100) .. "%)"
                    end
                end)
                healthConnections[obj] = conn
            else
                label.Text = obj.Name
            end
        else
            -- Generator progress or item name
            local progress = obj:FindFirstChild("Progress")
            if progress and progress:IsA("NumberValue") then
                label.Text = math.floor(progress.Value) .. "%"
                local conn = progress.Changed:Connect(function()
                    if label.Parent then
                        label.Text = math.floor(progress.Value) .. "%"
                    end
                end)
                progressConnections[obj] = conn
            else
                label.Text = obj.Name
            end
        end
    end)
end

-- Remove ESP from object
local function removeESP(obj, espName)
    if not obj then return end
    pcall(function()
        if obj:FindFirstChild(espName) then obj[espName]:Destroy() end
        if obj:FindFirstChild(espName .. "_Label") then obj[espName .. "_Label"]:Destroy() end
        if healthConnections[obj] then
            healthConnections[obj]:Disconnect()
            healthConnections[obj] = nil
        end
        if progressConnections[obj] then
            progressConnections[obj]:Disconnect()
            progressConnections[obj] = nil
        end
    end)
end

-- Apply ESP to all killers currently in folder
local function applyKillersESP()
    if not killersFolder then return end
    for _, killer in ipairs(killersFolder:GetChildren()) do
        if killer:IsA("Model") then
            addESP(killer, "Visual_ESP_Killer", Color3.fromRGB(255, 0, 0), true)
        end
    end
end

-- Apply ESP to all survivors currently in folder
local function applySurvivorsESP()
    if not survivorsFolder then return end
    for _, survivor in ipairs(survivorsFolder:GetChildren()) do
        if survivor:IsA("Model") then
            addESP(survivor, "Visual_ESP_Survivor", Color3.fromRGB(255, 255, 0), true)
        end
    end
end

-- Apply ESP to all generators in current map → NARANJA
local function applyGeneratorsESP()
    local map = getCurrentMapFolder()
    if not map then return end
    for _, obj in ipairs(map:GetChildren()) do
        if obj.Name == "Generator" then
            addESP(obj, "Visual_ESP_Generator", Color3.fromRGB(255, 165, 0), false) -- Orange
        end
    end
end

-- Apply ESP to all items in current map → BLANCO
local function applyItemsESP()
    local map = getCurrentMapFolder()
    if not map then return end
    for _, obj in ipairs(map:GetChildren()) do
        if obj.Name == "BloxyCola" or obj.Name == "Medkit" then
            addESP(obj, "Visual_ESP_Item", Color3.fromRGB(255, 255, 255), false) -- White
        end
    end
end

-- Clear all map-based ESP (called when map is destroyed)
local function clearMapESP()
    local oldMap = currentMapFolder
    if not oldMap then return end
    for _, obj in ipairs(oldMap:GetChildren()) do
        if obj.Name == "Generator" then
            removeESP(obj, "Visual_ESP_Generator")
        elseif obj.Name == "BloxyCola" or obj.Name == "Medkit" then
            removeESP(obj, "Visual_ESP_Item")
        end
    end
end

-- Setup player folder connections (Killers & Survivors)
local function setupPlayerConnections()
    for _, conn in pairs(playerConnections) do
        if conn.Connected then conn:Disconnect() end
    end
    playerConnections = {}

    if killersFolder then
        table.insert(playerConnections, killersFolder.ChildAdded:Connect(function(child)
            task.wait(0.2)
            if espKillersEnabled then
                addESP(child, "Visual_ESP_Killer", Color3.fromRGB(255, 0, 0), true)
            end
        end))
        table.insert(playerConnections, killersFolder.ChildRemoved:Connect(function(child)
            removeESP(child, "Visual_ESP_Killer")
        end))
    end

    if survivorsFolder then
        table.insert(playerConnections, survivorsFolder.ChildAdded:Connect(function(child)
            task.wait(0.2)
            if espSurvivorsEnabled then
                addESP(child, "Visual_ESP_Survivor", Color3.fromRGB(255, 255, 0), true)
            end
        end))
        table.insert(playerConnections, survivorsFolder.ChildRemoved:Connect(function(child)
            removeESP(child, "Visual_ESP_Survivor")
        end))
    end
end

-- Setup map folder watcher
local function setupMapWatcher()
    for _, conn in pairs(mapConnections) do
        if conn.Connected then conn:Disconnect() end
    end
    mapConnections = {}

    local ingame = workspaceService:FindFirstChild("Map") and workspaceService.Map:FindFirstChild("Ingame")
    if not ingame then return end

    local mapAddedConn = ingame.ChildAdded:Connect(function(child)
        if child.Name == "Map" then
            task.wait(1)
            currentMapFolder = child

            child.ChildAdded:Connect(function(obj)
                task.wait(0.2)
                if espGeneratorsEnabled and obj.Name == "Generator" then
                    addESP(obj, "Visual_ESP_Generator", Color3.fromRGB(255, 165, 0), false)
                elseif espItemsEnabled and (obj.Name == "BloxyCola" or obj.Name == "Medkit") then
                    addESP(obj, "Visual_ESP_Item", Color3.fromRGB(255, 255, 255), false)
                end
            end)

            child.ChildRemoved:Connect(function(obj)
                if obj.Name == "Generator" then
                    removeESP(obj, "Visual_ESP_Generator")
                elseif obj.Name == "BloxyCola" or obj.Name == "Medkit" then
                    removeESP(obj, "Visual_ESP_Item")
                end
            end)

            if espGeneratorsEnabled then applyGeneratorsESP() end
            if espItemsEnabled then applyItemsESP() end
        end
    end)

    local mapRemovedConn = ingame.ChildRemoved:Connect(function(child)
        if child.Name == "Map" then
            clearMapESP()
            currentMapFolder = nil
        end
    end)

    table.insert(mapConnections, mapAddedConn)
    table.insert(mapConnections, mapRemovedConn)

    local existingMap = getCurrentMapFolder()
    if existingMap then
        currentMapFolder = existingMap
        task.spawn(function()
            task.wait(2)
            if espGeneratorsEnabled then applyGeneratorsESP() end
            if espItemsEnabled then applyItemsESP() end
        end)
    end
end

-- Initial setup
task.spawn(function()
    task.wait(3)
    local players = workspaceService:FindFirstChild("Players")
    if players then
        killersFolder = players:FindFirstChild("Killers")
        survivorsFolder = players:FindFirstChild("Survivors")
        setupPlayerConnections()
        if espKillersEnabled then applyKillersESP() end
        if espSurvivorsEnabled then applySurvivorsESP() end
    end
    setupMapWatcher()
end)

-- UI Controls
EspSection:Toggle({
    Title = "Esp Killers",
    Type = "Checkbox",
    Default = false,
    Callback = function(state)
        espKillersEnabled = state
        if state then applyKillersESP() else
            if killersFolder then
                for _, k in ipairs(killersFolder:GetChildren()) do
                    removeESP(k, "Visual_ESP_Killer")
                end
            end
        end
    end
})

EspSection:Toggle({
    Title = "Esp Survivors",
    Type = "Checkbox",
    Default = false,
    Callback = function(state)
        espSurvivorsEnabled = state
        if state then applySurvivorsESP() else
            if survivorsFolder then
                for _, s in ipairs(survivorsFolder:GetChildren()) do
                    removeESP(s, "Visual_ESP_Survivor")
                end
            end
        end
    end
})

EspSection:Toggle({
    Title = "Esp Generators",
    Type = "Checkbox",
    Default = false,
    Callback = function(state)
        espGeneratorsEnabled = state
        if state then applyGeneratorsESP() else
            local map = getCurrentMapFolder()
            if map then
                for _, gen in ipairs(map:GetChildren()) do
                    if gen.Name == "Generator" then
                        removeESP(gen, "Visual_ESP_Generator")
                    end
                end
            end
        end
    end
})

EspSection:Toggle({
    Title = "Esp Items",
    Type = "Checkbox",
    Default = false,
    Callback = function(state)
        espItemsEnabled = state
        if state then applyItemsESP() else
            local map = getCurrentMapFolder()
            if map then
                for _, item in ipairs(map:GetChildren()) do
                    if item.Name == "BloxyCola" or item.Name == "Medkit" then
                        removeESP(item, "Visual_ESP_Item")
                    end
                end
            end
        end
    end
})

----------------------------------------------------------------
-- Character Tab
----------------------------------------------------------------
local CharacterTab = Window:Tab({
    Title = "Character",
    Icon = "user",
    Locked = false,
})

----------------------------------------------------------------
-- Killers Section
----------------------------------------------------------------
local KillersSection = CharacterTab:Section({
    Title = "Killers",
    Opened = true,
})

KillersSection:Button({
    Title = "Slasher",
    Locked = true,
    Callback = function()
        loadstring(game:HttpGet(""))()
    end
})

----------------------------------------------------------------
-- Survivors Section
----------------------------------------------------------------
local SurvivorsSection = CharacterTab:Section({
    Title = "Survivors",
    Opened = true,
})

SurvivorsSection:Button({
    Title = "Veeronica",
    Callback = function()
        loadstring(game:HttpGet("https://gist.githubusercontent.com/gloveringdevting/67624464d0d1f0c753c2d3780fae61b3/raw/GlovSaken%2520(Veeronica)"))()
    end
})

----------------------------------------------------------------
-- Sentinels Section
----------------------------------------------------------------
local SentinelsSection = CharacterTab:Section({
    Title = "Sentinels",
    Opened = true,
})

SentinelsSection:Button({
    Title = "Guest1337",
    Callback = function()
        loadstring(game:HttpGet("https://gist.githubusercontent.com/gloveringdevting/67624464d0d1f0c753c2d3780fae61b3/raw/GlovSaken%2520(Guest1337)"))()
    end
})

SentinelsSection:Button({
    Title = "Shedletsky",
    Callback = function()
        loadstring(game:HttpGet("https://gist.githubusercontent.com/gloveringdevting/67624464d0d1f0c753c2d3780fae61b3/raw/GlovSaken%2520(Shedletsky)"))()
    end
})

SentinelsSection:Button({
    Title = "Chance",
    Callback = function()
        loadstring(game:HttpGet("https://gist.githubusercontent.com/gloveringdevting/67624464d0d1f0c753c2d3780fae61b3/raw/GlovSaken%2520(Chance)"))()
    end
})

SentinelsSection:Button({
    Title = "TwoTime",
    Callback = function()
        loadstring(game:HttpGet("https://gist.githubusercontent.com/gloveringdevting/67624464d0d1f0c753c2d3780fae61b3/raw/GlovSaken%2520(TwoTime)"))()
    end
})

----------------------------------------------------------------
-- Supports Section
----------------------------------------------------------------
local SupportsSection = CharacterTab:Section({
    Title = "Supports",
    Opened = true,
})

SupportsSection:Button({
    Title = "Dusekkar",
    Callback = function()
        loadstring(game:HttpGet("https://gist.githubusercontent.com/gloveringdevting/67624464d0d1f0c753c2d3780fae61b3/raw/GlovSaken%2520(Dusekkar)"))()
    end
})

SupportsSection:Button({
    Title = "Elliot",
    Locked = true,
    Callback = function()
        loadstring(game:HttpGet(""))()
    end
})

----------------------------------------------------------------
-- Interface Tab
----------------------------------------------------------------
local InterfaceTab = Window:Tab({
    Title = "Interface",
    Icon = "scan",
    Locked = false,
})

----------------------------------------------------------------
-- UI Functions Section
----------------------------------------------------------------
local UIFunctionsSection = InterfaceTab:Section({ 
    Title = "UI Functions",
    Opened = true,
})

-- Close UI
InterfaceTab:Button({
    Title = "Close UI",
    Locked = false,
    Callback = function()
        Window:Destroy()
    end
})